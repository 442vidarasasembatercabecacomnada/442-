return function(mainTab, lib)

    local LocalPlayer = game:GetService("Players").LocalPlayer
    local UserInputService = game:GetService("UserInputService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local PlayerControl = require(game:GetService("ReplicatedFirst").Classes.PlayerControl)
    local ChampionData = require(ReplicatedStorage.DataBins.ChampionData)
    local AbilityData = require(ReplicatedStorage.DataBins.AbilityData)
    local Actions = require(ReplicatedStorage.Actions)
    local Values = require(ReplicatedStorage.Values)

    local isSupported = getgenv().isSupported
    local isPremium = getgenv().isPremium
    local expireDate = getgenv().expireDate

    local funcs = {}
    local connections = {}
    local states = {}
    local hooks = {}

    function funcs.ConnectRunService(string, type, func)
        if connections[string] then
            connections[string]:Disconnect()
        end
        
        connections[string] = game:GetService("RunService")[type]:Connect(func)
        
        return connections[string]
    end

    function funcs.DisconnectRunService(string)
        if connections[string] then
            connections[string]:Disconnect()
            connections[string] = nil
            return true
        end
    end

    function funcs.NotPremium(tab, string)
        tab:AddButton({
            Title = string,
            Description = "Exclusive premium feature"
        })
    end

    function funcs.NotSupported(tab, string)
        tab:AddButton({
            Title = string,
            Description = "Unsupported executor"
        })
    end

    function funcs.getRadiusIncreaseByPing()
        if states.autocompensator then
            local ping = math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
            if ping <= 50 then
                return 0.05
            elseif ping <= 100 then
                return 0.08
            elseif ping <= 150 then
                return 0.13
            elseif ping <= 200 then
                return 0.18
            else
                return 0.25
            end
        else
            return states.pingcompensator
        end
    end

    function funcs.IsAbilityActive()
        return LocalPlayer.Character
            and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            :FindFirstChild("DeflectBillboardGui")
            :FindFirstChild("ActiveAbilityLabel", true)
            .Visible
    end

    function funcs.IsThreat()
        local playerModel = Workspace:FindFirstChild(player.Name)
        local highlight = playerModel
            and playerModel:FindFirstChildWhichIsA('Highlight')
        return highlight
            and highlight.Enabled
            and math.abs(highlight.FillTransparency - 0.34)
                < 0.001
    end

    local autoparryconfig = {

    }

    local BASE_PARRY_RADIUS = 15
    local TORO_BALL_FIXED_PARRY_RADIUS = 20
    local MIN_SPEED_FOR_RADIUS_INCREASE = 40
    local MAX_PARRY_RADIUS = 50
    local PARRY_COOLDOWN = 0
    local ENABLE_DIRECTION_FILTER = true
    local DIRECTION_DOT_THRESHOLD = 0.707
    local CLASH_SPAM_RADIUS = 15
    local ENABLE_PREDICTION_FILTER = true
    local PREDICTION_FRAMES = 2
    local PREDICTION_TOLERANCE = 0.2
    local ENABLE_CURVE_DETECTION = true
    local CURVE_ANGLE_THRESHOLD = 45
    local MIN_SPEED_FOR_CURVE_DETECTION = 10

    local ball, trackedBallType
    local lastParryTime = 0
    local parryVisual
    local previousBallPosition
    local lastBallMovementVector = Vector3.zero
    local lastBallSpeed = 0
    local announcementBlockUntil = 0

    local TARGET_SOUNDS = {
        ['rbxassetid://129349547626045'] = 1.7,
        ['rbxassetid://15164222785'] = 0.5,
    }

    local soundBlockedUntil = 0
    local activeSounds = {}

    local function IsSoundPlaying()
        return tick() < soundBlockedUntil
    end

    funcs.ConnectRunService("BypassGazo", "Heartbeat", function()
        if not states.bypassgazo then return end
        for sound in pairs(activeSounds) do
            if not sound.Parent or not sound.Playing then
                activeSounds[sound] = nil
            end
        end
    end)

    workspace.DescendantAdded:Connect(function(descendant)
        if not states.bypassgazo then return end
        if descendant:IsA('Sound') and TARGET_SOUNDS[descendant.SoundId] then
            
            local connection
            connection = descendant:GetPropertyChangedSignal("Playing"):Connect(function()
                if descendant.Playing then
                    local blockTime = TARGET_SOUNDS[descendant.SoundId]
                    activeSounds[descendant] = true
                    soundBlockedUntil = tick() + blockTime
                end
            end)
            
            if descendant.Playing then
                local blockTime = TARGET_SOUNDS[descendant.SoundId]
                activeSounds[descendant] = true
                soundBlockedUntil = tick() + blockTime
            end
        end
    end)

    local function SetupAnnouncementMonitor()
        local success, result = pcall(function()
            local notificationGui = player.PlayerGui
                :WaitForChild('RunTimeModules', 10)
                :WaitForChild('NotificationGui', 10)
            local gameAnnouncement =
                notificationGui:WaitForChild('GameAnnouncement', 10)

            if gameAnnouncement then
                gameAnnouncement
                    :GetPropertyChangedSignal('Visible')
                    :Connect(function()
                        if gameAnnouncement.Visible then
                            announcementBlockUntil = os.clock() + 0.1
                        end
                    end)
                return true
            end
            return false
        end)
    end

    SetupAnnouncementMonitor()

    local Players = game:GetService("Players") 
    local UserInputService = game:GetService("UserInputService") 
    local VIM = game:GetService("VirtualInputManager") 
    local player = Players.LocalPlayer
    local deflectLabel
    pcall(function()
        local playerGui = player:FindFirstChild("PlayerGui")
        local hud = playerGui and playerGui:FindFirstChild("HUD")
        local holderBottom = hud and hud:FindFirstChild("HolderBottom")
        local toolbarButtons = holderBottom and holderBottom:FindFirstChild("ToolbarButtons")
        local deflectButton = toolbarButtons and toolbarButtons:FindFirstChild("DeflectButton")
        deflectLabel = deflectButton and deflectButton:FindFirstChild("KeyCodeLabel")
    end)

    local keyEnum
    local function PerformParryAction()
        if game:GetService("UserInputService").TouchEnabled then
            local actions = require(game.ReplicatedStorage.Actions)
            actions["USE_DEFLECT"]:Fire(nil, nil, nil, nil)
        else
            local keyText = deflectLabel.Text
            if keyText == "" then return end  

            keyEnum = Enum.KeyCode[keyText]
            if not keyEnum then return end

            game:GetService("VirtualInputManager"):SendKeyEvent(true, keyEnum, false, game)
            game:GetService("VirtualInputManager"):SendKeyEvent(false, keyEnum, false, game)
        end
    end

    local function UpdateOrCreateVisualizer(currentHrp, radius)
        if not states.autoparry or not states.showhitbox then
            if parryVisual then
                parryVisual:Destroy()
            end
            return
        end

        if not parryVisual then
            parryVisual = Instance.new('Part')
            parryVisual.Name = 'ParryVisualizer'
            parryVisual.Shape = Enum.PartType.Ball
            parryVisual.Material = Enum.Material.ForceField
            parryVisual.Color = Color3.fromRGB(255, 255, 255)
            parryVisual.Transparency = 0.75
            parryVisual.Anchored = true
            parryVisual.CanCollide = false
            parryVisual.CanQuery = false
            parryVisual.CanTouch = false
            parryVisual.Locked = true
            parryVisual.Parent = Workspace
        end

        local diameter = radius * 2
        parryVisual.Size = Vector3.new(diameter, diameter, diameter)
        parryVisual.CFrame = currentHrp.CFrame
    end

    local function DestroyVisualizer()
        if parryVisual then
            parryVisual:Destroy()
            parryVisual = nil
        end
    end

    local function AutoParryLoop(deltaTime)
        if not states.autoparry or deltaTime <= 0 then
            return
        end

        local currentHrp = player.Character
            and player.Character:FindFirstChild('HumanoidRootPart')
        if not currentHrp then
            DestroyVisualizer()
            return
        end

        humanoidRootPart = currentHrp

        if funcs.IsAbilityActive() then
            return
        end

        if not funcs.IsThreat() then
            return
        end

        if os.clock() < announcementBlockUntil then
            return
        end

        if IsSoundPlaying() and states.bypassgazo then
            return
        end

        local hrpPos = humanoidRootPart.Position
        local primaryBall = Workspace:FindFirstChild("Ball")
        local secondaryBall = Workspace:FindFirstChild("ToroBall")
        local currentBall = primaryBall or secondaryBall

        if not currentBall then
            DestroyVisualizer()
            ball = nil
            trackedBallType = nil
            previousBallPosition = nil
            return
        end

        trackedBallType = (currentBall == secondaryBall) and 'Toro' or 'Normal'

        local ballPos = currentBall.Position
        local ballSpeed = 0
        local ballMovementVector = Vector3.zero

        if previousBallPosition then
            ballMovementVector = ballPos - previousBallPosition
            ballSpeed = ballMovementVector.Magnitude / deltaTime
        end
        previousBallPosition = ballPos

        local isMakingSharpCurve = false
        if
            ENABLE_CURVE_DETECTION
            and ballSpeed > MIN_SPEED_FOR_CURVE_DETECTION
            and lastBallMovementVector.Magnitude > 0
        then
            local currentBallDirectionUnit = ballMovementVector.Unit
            local lastBallDirectionUnit = lastBallMovementVector.Unit
            if
                currentBallDirectionUnit.Magnitude > 0.99
                and lastBallDirectionUnit.Magnitude > 0.99
            then
                local dotProduct =
                    currentBallDirectionUnit:Dot(lastBallDirectionUnit)
                local angle = math.deg(math.acos(math.clamp(dotProduct, -1, 1)))
                isMakingSharpCurve = (angle > CURVE_ANGLE_THRESHOLD)
            end
        end
        lastBallMovementVector = ballMovementVector
        lastBallSpeed = ballSpeed

        if ballSpeed < 0.05 then
            local radius = (trackedBallType == 'Toro')
                    and TORO_BALL_FIXED_PARRY_RADIUS
                or BASE_PARRY_RADIUS
            UpdateOrCreateVisualizer(humanoidRootPart, radius)
            return
        end

        local parryRadius = (trackedBallType == 'Toro')
                and TORO_BALL_FIXED_PARRY_RADIUS
            or BASE_PARRY_RADIUS
        if
            trackedBallType == 'Normal'
            and ballSpeed >= MIN_SPEED_FOR_RADIUS_INCREASE
        then
            parryRadius = math.min(
                parryRadius + (ballSpeed * getRadiusIncreaseByPing()),
                MAX_PARRY_RADIUS
            )
        end

        UpdateOrCreateVisualizer(humanoidRootPart, parryRadius)

        local distance = (hrpPos - ballPos).Magnitude
        local currentTime = os.clock()

        if currentTime - lastParryTime < PARRY_COOLDOWN then
            return
        end

        local shouldParry = false

        if trackedBallType == 'Normal' and funcs.IsThreat() then
            if distance <= parryRadius and not isMakingSharpCurve then
                local directionCheckPassed = true
                if ENABLE_DIRECTION_FILTER then
                    local vectorToPlayer = (hrpPos - ballPos).Unit
                    local ballDirectionUnit = ballMovementVector.Unit
                    if
                        ballMovementVector.Magnitude > 0.01
                        and ballDirectionUnit.Magnitude > 0.99
                    then
                        local directionDot = ballDirectionUnit:Dot(vectorToPlayer)
                        directionCheckPassed = (
                            directionDot > DIRECTION_DOT_THRESHOLD
                        )
                    else
                        directionCheckPassed = false
                    end
                end

                local predictionCheckPassed = true
                if
                    directionCheckPassed
                    and ENABLE_PREDICTION_FILTER
                    and ballMovementVector.Magnitude > 0.01
                then
                    local predictedBallPos = ballPos
                        + (ballMovementVector * PREDICTION_FRAMES)
                    local predictedDistance = (hrpPos - predictedBallPos).Magnitude
                    predictionCheckPassed = (
                        predictedDistance <= distance + PREDICTION_TOLERANCE
                    )
                end

                shouldParry = directionCheckPassed and predictionCheckPassed
            end

            if
                not shouldParry
                and distance <= CLASH_SPAM_RADIUS
                and not isMakingSharpCurve
            then
                shouldParry = true
            end
        end

        if trackedBallType == 'Toro' then
            local toroSpamRadius = CLASH_SPAM_RADIUS + 5

            if distance <= toroSpamRadius then
                shouldParry = true
            elseif distance <= parryRadius and not isMakingSharpCurve then
                local directionCheckPassed = true
                if ENABLE_DIRECTION_FILTER then
                    local vectorToPlayer = (hrpPos - ballPos).Unit
                    local ballDirectionUnit = ballMovementVector.Unit
                    if
                        ballMovementVector.Magnitude > 0.01
                        and ballDirectionUnit.Magnitude > 0.99
                    then
                        local directionDot = ballDirectionUnit:Dot(vectorToPlayer)
                        directionCheckPassed = (
                            directionDot > DIRECTION_DOT_THRESHOLD * 0.5
                        )
                    else
                        directionCheckPassed = false
                    end
                end

                local predictionCheckPassed = true
                if
                    directionCheckPassed
                    and ENABLE_PREDICTION_FILTER
                    and ballMovementVector.Magnitude > 0.01
                then
                    local predictedBallPos = ballPos
                        + (ballMovementVector * PREDICTION_FRAMES)
                    local predictedDistance = (hrpPos - predictedBallPos).Magnitude
                    predictionCheckPassed = (
                        predictedDistance <= distance + PREDICTION_TOLERANCE
                    )
                end

                shouldParry = directionCheckPassed and predictionCheckPassed
            end
        end

        if shouldParry then
            PerformParryAction()
            lastParryTime = currentTime
        end
    end

    mainTab:AddParagraph({
        Title = "Hello! ", LocalPlayer.DisplayName,
        Content = "License valid until: ", tostring(expireDate),
    })

    mainTab:AddToggle('AutoParry', {
        Title = "Auto Parry",
        Description = translator.t.apdesc,
        Default = true,
        Keybind = "...",
        Callback = function(boolean)
            states.autoparry = boolean
            if boolean then
                getRadiusIncreaseByPing()
                funcs.ConnectRunService("autoparry", "Heartbeat", AutoParryLoop)
            else
                funcs.DisconnectRunService("autoparry")
                DestroyVisualizer()
                ball = nil
                trackedBallType = nil
                previousBallPosition = nil
            end
        end,
    })

    if isPremium then
        mainTab:AddSlider('PingCompensator', {
            Title = "Ping Compensator",
            Description = "Adjust according to your ms",
            Default = 5,
            Min = 1,
            Max = 25,
            Rounding = 0,
            Callback = function(int)
                states.pingcompensator = int / 100
            end
        })
    else funcs.NotPremium(mainTab, "Ping Compensator") end

    mainTab:AddToggle('AutoCompensator', {
        Title = translator.t.autocomptitle,
        Description = translator.t.autocompdesc,
        Default = true,
        Callback = function(boolean)
            states.autocompensator = boolean
        end
    })

    if isPremium then
        mainTab:AddToggle('BypassGazo', {
            Title = 'Bypass gazo',
            Description = translator.t.bpsgazotitle,
            Default = true,
            Callback = function(boolean)
                states.bypassgazo = boolean
            end
        })
    else funcs.NotPremium(MainTab, "Bypass gazo") end

    mainTab:AddToggle('ShowHitbox', {
        Title = "Show Hitbox",
        Description = "Shows the parry hitbox visual",
        Default = false,
        Callback = function(boolean)
            states.showhitbox = boolean
            if not boolean then
                DestroyVisualizer()
            end
        end
    })

    if isSupported then
        local allabilityes = {}
        for charName, data in pairs(ChampionData) do
            allabilityes[charName] = {}
            for _, slot in pairs(data.Abilities) do
                for _, skillName in pairs(slot) do
                    local config = AbilityData[skillName]
                    if config and config.HoverData and config.HoverData.AutoDeflect == true then
                        table.insert(allabilityes[charName], skillName)
                    end
                end
            end
        end

        function funcs.useAbility()
            local inv = PlayerControl.Inventory
            local idEquipado = inv.EquippedChampions and inv.EquippedChampions[1]
            
            if not idEquipado then
                return 
            end

            local charInstancia = inv.Champions[idEquipado]
            local charNome = charInstancia.Type
            local seuNivel = charInstancia.Level or 0
            
            local habilidadesDisponiveis = allabilityes[charNome]
            
            if habilidadesDisponiveis and #habilidadesDisponiveis > 0 then
                for _, nomeSkill in ipairs(habilidadesDisponiveis) do
                    local config = AbilityData[nomeSkill]
                    local levelReq = config.LevelRequirement or 0
                    
                    if seuNivel >= levelReq then
                        
                        local emCooldown = PlayerControl.Ability.Cooldowns[nomeSkill]
                        
                        local cooldownsGlobalmenteDesativados = Values.COOLDOWNS_DISABLED:Get()
                        
                        if not emCooldown or cooldownsGlobalmenteDesativados then
                            local podeUsarPelaLogica = true
                            if config.UseCondition then
                                podeUsarPelaLogica = config.UseCondition(PlayerControl, PlayerControl) 
                            end

                            if podeUsarPelaLogica then
                                Actions.ABILITY_USE:Fire(nomeSkill)
                                
                                return
                            end
                        end
                    end
                end
            end
        end

        Actions.DEFLECT_RESULT:Connect(function(err)
            if err then
                if not states.AutoAbility then return end
                if not game:GetService("Players").LocalPlayer:GetAttribute('IsInGame') then return end
                if not funcs.IsThreat() then return end
                funcs.useAbility()
            end
        end)

        mainTab:AddToggle('AutoAbility', {
            Title = "Auto Ability",
            Description = "Use skills when parry misses",
            Default = true,
            Keybind = "...",
            Callback = function(boolean)
                states.AutoAbility = boolean
            end,
        })
    else funcs.NotSupported(mainTab, "Auto Ability") end

    local function FindBall()
        local ball = workspace:FindFirstChild("Ball")
        if not ball then
            for _, obj in pairs(workspace:GetChildren()) do
                if obj:IsA("BasePart") and (obj.Name:lower():find("ball") or obj.Shape == Enum.PartType.Ball) then
                    ball = obj
                    break
                end
            end
        end
        
        return ball
    end

    local function MoveToPosition(position)
        local character = LocalPlayer.Character
        if not character then return end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and rootPart then
            humanoid:MoveTo(position)
        end
    end

    function funcs.StartAIMovement()
        funcs.DisconnectRunService("BallFollowConnection")

        funcs.ConnectRunService("BallFollowConnection", "Heartbeat", function()
            if not LocalPlayer:GetAttribute('IsInGame') then
                return
            end
            
            if not states.aimovement then
                return
            end
            
            local ball = FindBall()
            if not ball then
                MoveToPosition(LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and LocalPlayer.Character.PrimaryPart.Position or Vector3.new())
                return
            end
            
            local character = LocalPlayer.Character
            if not character then return end
            
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if not rootPart then return end
            
            local ballPosition = ball.Position
            local myPosition = rootPart.Position
            
            local direction = (ballPosition - myPosition).Unit
            local distance = (ballPosition - myPosition).Magnitude
            
            if distance > 500 then
                return
            end
            
            local targetDistance = math.max(5, distance - 2)
            
            local targetPosition = ballPosition - (direction * targetDistance)
            MoveToPosition(targetPosition)
        end)
        
    end

    function funcs.StopAIMovement()
        funcs.DisconnectRunService("BallFollowConnection")
        
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:MoveTo(character.PrimaryPart.Position)
            end
        end
    end

    LocalPlayer:GetAttributeChangedSignal('IsInGame'):Connect(function()
        if not states.aimovement then return end
        
        local isInGame = LocalPlayer:GetAttribute('IsInGame')
        if not isInGame then
            funcs.StopAIMovement()
        else
            funcs.StartAIMovement()
        end
    end)

    if isPremium then
        mainTab:AddToggle('aimovement', {
            Title = 'AI Movement',
            Description = translator.t.aimovdesc,
            Default = false,
            Callback = function(boolean)
                states.aimovement = boolean
                
                if boolean then
                    if LocalPlayer:GetAttribute('IsInGame') then
                        funcs.StartAIMovement()
                    end
                else
                    funcs.StopAIMovement()
                end
            end
        })
    else funcs.NotPremium(mainTab, "Ai Movement") end

    function funcs.rotateXZ(x,z,angle)
        local cos, sin = math.cos(angle), math.sin(angle)
        return x*cos - z*sin, x*sin + z*cos
    end

    function funcs.getCurveVector(direction)
        local lookVector = workspace.CurrentCamera.CFrame.LookVector
        local x,y,z = lookVector.X, lookVector.Y, lookVector.Z

        if direction == "back" then
            x,y,z = -x,-y,-z
        elseif direction == "right" then
            x,z = -z,x
        elseif direction == "left" then
            x,z = z,-x
        elseif direction == "up" then
            y = y + 1
        elseif direction == "down" then
            y = y - 1
        elseif direction == "up right" then
            y = y + 0.7
            x,z = -z,x
        elseif direction == "up left" then
            y = y + 0.7
            x,z = z,-x
        elseif direction == "down right" then
            y = y - 0.7
            x,z = -z,x
        elseif direction == "down left" then
            y = y - 0.7
            x,z = z,-x
        elseif direction == "extreme right" then
            x,z = funcs.rotateXZ(x,z,math.rad(90))
        elseif direction == "extreme left" then
            x,z = funcs.rotateXZ(x,z,math.rad(-90))
        elseif direction == "extreme up" then
            y = y + 2
        elseif direction == "extreme down" then
            y = y - 2
        elseif direction == "back left" then
            x,z = funcs.rotateXZ(-x,-z,math.rad(45))
        elseif direction == "back right" then
            x,z = funcs.rotateXZ(-x,-z,math.rad(-45))
        elseif direction == "spiral" then
            local t = tick()
            local ang = t % (2*math.pi)
            x,z = funcs.rotateXZ(x,z,ang)
            y = y + math.sin(t) * 0.5
        elseif direction == "random" then
            local ang = math.rad(math.random(-180,180))
            x,z = funcs.rotateXZ(x,z,ang)
        end

        return x,y,z
    end

    mainTab:AddDropdown("autocurve", {
        Title = "Auto Curve",
        Description = "Curves the ball to selected direction",
        Values = {
        "off", "back", "right", "left", "up", "down", "random",
        "up right", "up left", "down right", "down left",
        "extreme right", "extreme left", "extreme up", "extreme down",
        "back right", "back left", "spiral" },
        Multi = false,
        Default = "off"
    }):OnChanged(function(Value)
        directionCurve = Value
    end)

    hooks.AutoCurve = hookmetamethod(game, '__namecall', function(self, ...)

        local method = getnamecallmethod()
        local args = {...}

        if directionCurve ~= "off" and method == 'FireServer' and self.Name == 'ReplicateCamLook' then
            local x, y, z = funcs.getCurveVector(directionCurve)
            
            args[1] = x
            args[2] = y
            args[3] = z
        end
        return hooks.AutoCurve(self, unpack(args))
    end)

    function funcs.findReadyZone()
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj.Name == "ReadyZone" then
                return obj
            end
        end
        return nil
    end

    local jaexecutou = false
    mainTab:AddToggle('AutoReady', {
        Title = "Auto Ready",
        Description = "Go to ready zone automatically",
        Default = false,
        Callback = function(boolean)
            if boolean then
                funcs.ConnectRunService("AutoReady", "Heartbeat", function()
                    if LocalPlayer.Character and not game.Players.LocalPlayer:GetAttribute('IsInGame') then
                        jaexecutou = true
                        if LocalPlayer.Character.Humanoid and funcs.findReadyZone() then
                            LocalPlayer.Character.Humanoid:MoveTo(funcs.findReadyZone().Position)
                        end
                    else
                        if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                            if not jaexecutou then return end
                            
                            LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position)
                            jaexecutou = false
                        end
                    end
                end)
            else
                funcs.DisconnectRunService("AutoReady")
                jaexecutou = false
                if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                    LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position)
                end
            end
        end,
    })

    local fov = workspace.CurrentCamera and math.clamp(workspace.CurrentCamera.FieldOfView, 70, 120) or 70

    mainTab:AddSlider("Fov", {
        Title = "FOV",
        Description = translator.t.fov,
        Default = 70,
        Min = 70,
        Max = 120,
        Rounding = 0,
        Callback = function(int)
            fov = int
        end,
    })

    funcs.ConnectRunService("fov", "RenderStepped", function()
        if workspace.CurrentCamera and fov ~= 70 then
            if workspace.CurrentCamera.FieldOfView ~= fov then
                workspace.CurrentCamera.FieldOfView = fov
            end
        end
    end)

    mainTab:AddSlider("MaxZoom", {
        Title = "Max Zoom",
        Description = "Zoom out camera to the max",
        Default = 45,
        Min = 45,
        Max = 200,
        Rounding = 0,
        Callback = function(int)
            if LocalPlayer then 
                LocalPlayer.CameraMaxZoomDistance = int
            end
        end,
    })

    local RunService=game:GetService("RunService");local Workspace=game:GetService("Workspace");local FX_FOLDER_NAME="FX";local TARGET_PART_NAME="BallShadow";local DECAL_NAME_INSIDE="Decal";local FOLLOWER_SPHERE_NAME="Ball";local TARGET_TRACKED_COLOR=Color3.fromRGB(111,111,111);local MIN_TRANSPARENCY=0.3;local MAX_TRANSPARENCY=1.0;local MIN_HEIGHT_OFFSET=2.0;local MAX_HEIGHT_OFFSET=280.0;local LERP_FACTOR=1;local isTracking=false;local trackedPartInstance=nil;local trackedDecalInstance=nil;local followerSphere=nil;local renderConnection=nil;local function StartTracking(partToTrack,decalToTrack)if isTracking or renderConnection then return end;if not partToTrack or not decalToTrack then return end;isTracking=true;trackedPartInstance=partToTrack;trackedDecalInstance=decalToTrack;trackedPartInstance.Color=TARGET_TRACKED_COLOR;local oldFollower=Workspace:FindFirstChild(FOLLOWER_SPHERE_NAME);if oldFollower then oldFollower:Destroy()end;followerSphere=Instance.new("Part");followerSphere.Name=FOLLOWER_SPHERE_NAME;followerSphere.Shape=Enum.PartType.Ball;followerSphere.Size=Vector3.new(4,4,4);followerSphere.Color=Color3.fromRGB(255,255,255);followerSphere.Material=Enum.Material.Air;followerSphere.Anchored=true;followerSphere.CanCollide=false;followerSphere.Transparency=1;followerSphere.Parent=Workspace;local initialTransparency=trackedDecalInstance.Transparency;local initialNormTrans=math.clamp((initialTransparency-MIN_TRANSPARENCY)/(MAX_TRANSPARENCY-MIN_TRANSPARENCY),0,1);local initialHeight=MIN_HEIGHT_OFFSET+(MAX_HEIGHT_OFFSET-MIN_HEIGHT_OFFSET)*initialNormTrans;local initialShadowPos=trackedPartInstance.Position;followerSphere.Position=Vector3.new(initialShadowPos.X,initialShadowPos.Y+initialHeight,initialShadowPos.Z);renderConnection=RunService.RenderStepped:Connect(function(deltaTime)if not trackedPartInstance or not trackedPartInstance.Parent or not trackedDecalInstance or not trackedDecalInstance.Parent or trackedDecalInstance.Parent~=trackedPartInstance or not followerSphere or not followerSphere.Parent then StopTracking();return end;local currentTransparency=trackedDecalInstance.Transparency;local normalizedTransparency=math.clamp((currentTransparency-MIN_TRANSPARENCY)/(MAX_TRANSPARENCY-MIN_TRANSPARENCY),0,1);local calculatedHeightOffset=MIN_HEIGHT_OFFSET+(MAX_HEIGHT_OFFSET-MIN_HEIGHT_OFFSET)*normalizedTransparency;local shadowPosition=trackedPartInstance.Position;local sphereTargetPosition=Vector3.new(shadowPosition.X,shadowPosition.Y+calculatedHeightOffset,shadowPosition.Z);followerSphere.Position=followerSphere.Position:Lerp(sphereTargetPosition,LERP_FACTOR)end)end;function StopTracking()if not isTracking then return end;if renderConnection then renderConnection:Disconnect();renderConnection=nil end;local sphereToDestroy=followerSphere or Workspace:FindFirstChild(FOLLOWER_SPHERE_NAME);if sphereToDestroy and sphereToDestroy.Parent then sphereToDestroy:Destroy()end;followerSphere=nil;trackedPartInstance=nil;trackedDecalInstance=nil;isTracking=false end;local fxFolder=Workspace:WaitForChild(FX_FOLDER_NAME,30);if fxFolder then fxFolder.ChildAdded:Connect(function(child)if child.Name==TARGET_PART_NAME and child:IsA("BasePart")and not isTracking then task.wait(0.1);local decal=child:FindFirstChild(DECAL_NAME_INSIDE);if decal and decal:IsA("Decal")and not isTracking then StartTracking(child,decal)end end end);fxFolder.ChildRemoved:Connect(function(child)if child==trackedPartInstance then StopTracking()end end);if not isTracking then local initialPart=fxFolder:FindFirstChild(TARGET_PART_NAME);if initialPart and initialPart:IsA("BasePart")then local initialDecal=initialPart:FindFirstChild(DECAL_NAME_INSIDE);if initialDecal and initialDecal:IsA("Decal")and not isTracking then StartTracking(initialPart,initialDecal)end end end end
    local Workspace=game:GetService("Workspace");local TARGET_HIGHLIGHT_NAME="Highlight";local TARGET_FILL_COLOR_RGB={R=255,G=149,B=0};local TARGET_OUTLINE_COLOR_RGB={R=255,G=238,B=0};local TARGET_FILL_TRANSPARENCY=1;local TARGET_OUTLINE_TRANSPARENCY=0;local TARGET_ENABLED=true;local TARGET_DEPTH_MODE=Enum.HighlightDepthMode.AlwaysOnTop;local COLOR_COMPONENT_TOLERANCE=0.01;local highlightPartProcessed={};local function runBallShadowTrackingLogic()local RunService_BS=game:GetService("RunService");local Workspace_BS=game:GetService("Workspace");local FX_FOLDER_NAME_BS="FX";local TARGET_PART_NAME_BS="BallShadow";local DECAL_NAME_INSIDE_BS="Decal";local FOLLOWER_SPHERE_NAME_BS="ToroBall";local TARGET_PART_INITIAL_COLOR_BS=Color3.fromRGB(163,162,165);local MIN_TRANSPARENCY_BS=0.3;local MAX_TRANSPARENCY_BS=1.0;local MIN_HEIGHT_OFFSET_BS=2.0;local MAX_HEIGHT_OFFSET_BS=280.0;local LERP_FACTOR_BS=1;local isTracking_BS=false;local trackedPartInstance_BS=nil;local trackedDecalInstance_BS=nil;local followerSphere_BS=nil;local renderConnection_BS=nil;local childAddedConnection_BS=nil;local childRemovedConnection_BS=nil;local function StopTracking_BS()if not isTracking_BS then return end;if renderConnection_BS then renderConnection_BS:Disconnect();renderConnection_BS=nil;end;if childAddedConnection_BS then childAddedConnection_BS:Disconnect();childAddedConnection_BS=nil;end;if childRemovedConnection_BS then childRemovedConnection_BS:Disconnect();childRemovedConnection_BS=nil;end;local sphereToDestroy=followerSphere_BS or Workspace_BS:FindFirstChild(FOLLOWER_SPHERE_NAME_BS);if sphereToDestroy and sphereToDestroy.Parent then sphereToDestroy:Destroy()end;followerSphere_BS=nil;trackedPartInstance_BS=nil;trackedDecalInstance_BS=nil;isTracking_BS=false end;local function StartTracking_BS(partToTrack,decalToTrack)if isTracking_BS or renderConnection_BS then return end;if not partToTrack or not decalToTrack then return end;isTracking_BS=true;trackedPartInstance_BS=partToTrack;trackedDecalInstance_BS=decalToTrack;local oldFollower=Workspace_BS:FindFirstChild(FOLLOWER_SPHERE_NAME_BS);if oldFollower then oldFollower:Destroy()end;followerSphere_BS=Instance.new("Part");followerSphere_BS.Name=FOLLOWER_SPHERE_NAME_BS;followerSphere_BS.Shape=Enum.PartType.Ball;followerSphere_BS.Size=Vector3.new(4,4,4);followerSphere_BS.Color=Color3.fromRGB(255,0,0);followerSphere_BS.Material=Enum.Material.Neon;followerSphere_BS.Anchored=true;followerSphere_BS.CanCollide=false;followerSphere_BS.Transparency=0;followerSphere_BS.Parent=Workspace_BS;local initialTransparency=trackedDecalInstance_BS.Transparency;local initialNormTrans=math.clamp((initialTransparency-MIN_TRANSPARENCY_BS)/(MAX_TRANSPARENCY_BS-MIN_TRANSPARENCY_BS),0,1);local initialHeight=MIN_HEIGHT_OFFSET_BS+(MAX_HEIGHT_OFFSET_BS-MIN_HEIGHT_OFFSET_BS)*initialNormTrans;local initialShadowPos=trackedPartInstance_BS.Position;followerSphere_BS.Position=Vector3.new(initialShadowPos.X,initialShadowPos.Y+initialHeight,initialShadowPos.Z);renderConnection_BS=RunService_BS.RenderStepped:Connect(function(deltaTime)if not trackedPartInstance_BS or not trackedPartInstance_BS.Parent or not trackedDecalInstance_BS or not trackedDecalInstance_BS.Parent or trackedDecalInstance_BS.Parent~=trackedPartInstance_BS or not followerSphere_BS or not followerSphere_BS.Parent then StopTracking_BS();return end;local currentTransparency=trackedDecalInstance_BS.Transparency;local normalizedTransparency=math.clamp((currentTransparency-MIN_TRANSPARENCY_BS)/(MAX_TRANSPARENCY_BS-MIN_TRANSPARENCY_BS),0,1);local calculatedHeightOffset=MIN_HEIGHT_OFFSET_BS+(MAX_HEIGHT_OFFSET_BS-MIN_HEIGHT_OFFSET_BS)*normalizedTransparency;local shadowPosition=trackedPartInstance_BS.Position;local sphereTargetPosition=Vector3.new(shadowPosition.X,shadowPosition.Y+calculatedHeightOffset,shadowPosition.Z);followerSphere_BS.Position=followerSphere_BS.Position:Lerp(sphereTargetPosition,LERP_FACTOR_BS)end);if childAddedConnection_BS then childAddedConnection_BS:Disconnect();childAddedConnection_BS=nil;end;if childRemovedConnection_BS then childRemovedConnection_BS:Disconnect();childRemovedConnection_BS=nil;end end;local fxFolder_BS=Workspace_BS:WaitForChild(FX_FOLDER_NAME_BS,30);if fxFolder_BS then childAddedConnection_BS=fxFolder_BS.ChildAdded:Connect(function(child)if isTracking_BS then return end;if child.Name==TARGET_PART_NAME_BS and child:IsA("BasePart")and child.Color==TARGET_PART_INITIAL_COLOR_BS then task.wait(0.1);local decal=child:FindFirstChild(DECAL_NAME_INSIDE_BS);if decal and decal:IsA("Decal")then StartTracking_BS(child,decal)end end end);childRemovedConnection_BS=fxFolder_BS.ChildRemoved:Connect(function(child)if child==trackedPartInstance_BS then StopTracking_BS()end end);if not isTracking_BS then local initialPart=fxFolder_BS:FindFirstChild(TARGET_PART_NAME_BS);if initialPart and initialPart:IsA("BasePart")and initialPart.Color==TARGET_PART_INITIAL_COLOR_BS then task.wait(0.1);local initialDecal=initialPart:FindFirstChild(DECAL_NAME_INSIDE_BS);if initialDecal and initialDecal:IsA("Decal")then StartTracking_BS(initialPart,initialDecal)end end end;task.delay(10,function()if not isTracking_BS then if childAddedConnection_BS then childAddedConnection_BS:Disconnect();childAddedConnection_BS=nil;end;if childRemovedConnection_BS then childRemovedConnection_BS:Disconnect();childRemovedConnection_BS=nil;end end end)end end;local function areColorsSimilar(colorA_Color3,targetColor_RGBTable)if not colorA_Color3 or not targetColor_RGBTable then return false end;local r=math.abs(colorA_Color3.R-(targetColor_RGBTable.R/255))<COLOR_COMPONENT_TOLERANCE;local g=math.abs(colorA_Color3.G-(targetColor_RGBTable.G/255))<COLOR_COMPONENT_TOLERANCE;local b=math.abs(colorA_Color3.B-(targetColor_RGBTable.B/255))<COLOR_COMPONENT_TOLERANCE;return r and g and b end;local function processPartIfMatches(partInstance)if not partInstance or not partInstance:IsA("BasePart")or highlightPartProcessed[partInstance]then return end;local hi=partInstance:FindFirstChild(TARGET_HIGHLIGHT_NAME);if hi and hi:IsA("Highlight")then local nm=(hi.Name==TARGET_HIGHLIGHT_NAME);local en=(hi.Enabled==TARGET_ENABLED);local dm=(hi.DepthMode==TARGET_DEPTH_MODE);local ft=(math.abs(hi.FillTransparency-TARGET_FILL_TRANSPARENCY)<0.01);local ot=(math.abs(hi.OutlineTransparency-TARGET_OUTLINE_TRANSPARENCY)<0.01);local fc=areColorsSimilar(hi.FillColor,TARGET_FILL_COLOR_RGB);local oc=areColorsSimilar(hi.OutlineColor,TARGET_OUTLINE_COLOR_RGB);if nm and en and dm and fc and ft and oc and ot then highlightPartProcessed[partInstance]=true;runBallShadowTrackingLogic()end end end;Workspace.DescendantAdded:Connect(function(d)if d:IsA("BasePart")then task.wait(0.05);processPartIfMatches(d)elseif d:IsA("Highlight")and d.Name==TARGET_HIGHLIGHT_NAME and d.Parent then processPartIfMatches(d.Parent)end end);for _,d in ipairs(Workspace:GetDescendants())do if d:IsA("BasePart")then processPartIfMatches(d)end end

end
